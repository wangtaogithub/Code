#ifndef _TOOL_HEADER_#define _TOOL_HEADER_typedef signed char s8;typedef unsigned char u8;typedef signed short s16;typedef unsigned short u16;typedef signed int s32;typedef unsigned int u32;#define ADDR_MAX_LENGTH     2#define CMD_DATA_LENGTH     0#define CMD_HEAD_LENGTH     (sizeof(st_com_cmd_head) - CMD_DATA_LENGTH)#define MYBIG_ENDIAN        4321#define MYLITLE_ENDIAN      1234#define MAX_LINE_LENGTH     1000#define DRIVER_NUM		    30	// 驱动线数目#define SENSOR_NUM		    42	// 感应线数目#define HEX(a) ((a >= '0' && a <= '9') || (a >= 'A' && a <= 'F') || (a >= 'a' && a <= 'f'))#define TOOL_VERSION        "V1.0_20120401"/*----------------------------------error_type宏定义--------------------------*///ini文件打开错误-2147483647#define INI_FILE_OPEN_ERR       ((0x1<<0)|0x80000000)//ini文件读取错误-2147483646#define INI_FILE_READ_ERR       ((0x2<<0)|0x80000000)//ini文件非法           -2147483644#define INI_FILE_ILLEGAL        ((0x4<<0)|0x80000000)                      // -2147483640#define SHORT_TEST_ERROR        ((0x8<<0)|0x80000000)//cfg文件打开错误-2147483632#define CFG_FILE_OPEN_ERR       ((0x1<<4)|0x80000000)//cfg文件读取错误-2147483616#define CFG_FILE_READ_ERR       ((0x2<<4)|0x80000000)//cfg文件非法    -2147483584#define CFG_FILE_ILLEGAL        ((0x4<<4)|0x80000000)//升级文件打开错误#define UPDATE_FILE_OPEN_ERR    ((0x1<<8)|0x80000000)//升级文件读取错误#define UPDATE_FILE_READ_ERR    ((0x2<<8)|0x80000000)//升级文件非法#define UPDATE_FILE_ILLEGAL     ((0x4<<8)|0x80000000)//文件打开/创建错误#define FILE_OPEN_CREATE_ERR    ((0x1<<12)|0x80000000)//文件读取/写入错误#define FILE_READ_WRITE_ERR     ((0x2<<12)|0x80000000)//文件非法#define FILE_ILLEGAL            ((0x4<<12)|0x80000000)//节点打开错误#define NODE_OPEN_ERR           ((0x1<<16)|0x80000000)//节点读错误#define NODE_READ_ERR           ((0x2<<16)|0x80000000)//节点写错误#define NODE_WRITE_ERR          ((0x4<<16)|0x80000000)//驱动线数错误#define DRIVER_NUM_WRONG        ((0x1<<20)|0x80000000)//感应线数错误#define SENSOR_NUM_WRONG        ((0x2<<20)|0x80000000)//I2C锁定#define I2C_LOCKED              ((0x4<<20)|0x80000000)//I2C解锁#define I2C_UNLOCKED            ((0x8<<20)|0x80000000)//内存错误#define MEMORY_ERR              ((0x1<<24)|0x80000000)//I2C通信错误#define I2C_TRANS_ERR           ((0x2<<24)|0x80000000)//未获取到标志位#define COMFIRM_ERR             ((0x4<<24)|0x80000000)//进入升级模式错误#define ENTER_UPDATE_MODE_ERR   ((0x8<<24)|0x80000000)//Vendor ID非法#define VENDOR_ID_ILLEGAL       ((0x1<<28)|0x80000000)//Store error#define STORE_ERROR             ((0x2<<28)|0x80000000)//芯片型号错误#define NO_SUCH_CHIP_TYPE       ((0x4<<28)|0x80000000)/*----------------------------------与节点的通信协议--------------------------*/enum COM_MODE{    READ_DATA = 0,    WRITE_DATA = 1,    READ_IC_TYPE = 2,    WRITE_IC_TYPE = 3,    UPDATE_PROGRESS = 4,    READ_ERR_NO = 6,    RESERVED = 5,    READ_DRIVER_VERSION = 8,    DISABLE_IRQ = 7,    ENABLE_IRQ = 9,    ENTER_UPDATE_MODE = 11,    LEAVE_UPDATE_MODE = 13,    UPDATE_PROC = 15,};#pragma pack(1)typedef struct{    u8  wr;      //0:读数据 2:读IC型号 4:读错误码                //：写数据 3：写IC型号 5：预留 7：关中断 9：开中断 11:进入升级                //模式 13：退出升级模式 15：启动芯片升级流程    //--------------------    u8  flag;    //0:不需要标志位和中断1: 需要标志位  2:需要中断（未使用）    u8  flag_addr[ADDR_MAX_LENGTH];  //标志位地址    u8  flag_val;           //标志位值    u8  flag_relation;  //标志位地址处的值与标志位值的关系 0:不等于 1:等于 2:大于     					//3:小于 4：相与不等于0  5：相或等于0    u16 circle;         //轮询周期    u8  times;          //轮询次数    //--------------------    u8  retry;          //I2C通信重试次数    u16 delay;          //读前延时、写后延时    u16 data_len;       //数据长度    u8  addr_len;       //地址长度    u8  addr[ADDR_MAX_LENGTH];    //地址，单字节地址，放在第一个字节    u8  res[3];         //保留    u8  data[CMD_DATA_LENGTH];}st_com_cmd_head;#pragma pack()#define INIT_READ_CMD_HEAD(head, addr_length)       do {memset((s8*)&head, 0, sizeof(st_com_cmd_head));head.retry = 5;head.addr_len = addr_length;}while(0)#define INIT_WRITE_CMD_HEAD(head, addr_length)      do {memset((s8*)&head, 0, sizeof(st_com_cmd_head));head.retry = 5; head.addr_len = addr_length;head.wr = WRITE_DATA;}while(0)#define INIT_FLAG_READ(head, address, val)          do {head.flag = 1; head.flag_addr[0] = (address >> 8);head.flag_addr[1] = address & 0xff; head.flag_val = val; head.flag_relation = 1; head.circle = 20; head.times = 10;}while(0)#define INIT_FLAG_READ_SINGLE(head, address, val)   do {head.flag = 1; head.flag_addr[0] = address & 0xff;head.flag_val = val; head.flag_relation = 1; head.circle = 20; head.times = 10;}while(0)#define INIT_CFG_MEM_NAME(mem, mem_name) memcpy(mem.name, mem_name, strlen(mem_name) > 20 ? 20 : strlen(mem_name))//For Debug Use#define log_debug(fmt,arg...) DEBUG("<--GT-DEBUG-->"fmt, ##arg)//#define printf(fmt, arg...) log_debug(fmt, ##arg)#ifdef _LINUX_    #define log_print(level, tag, fmt, arg...)   printf(fmt, ##arg)#else   // #define FILE_DEBUG    #ifdef FILE_DEBUG        #include <stdio.h>        #include <time.h>		#include <android/log.h>        extern FILE* log_fp;        #define LOG_FILE_PATH "/sdcard/log.txt"        #define log_print(level, tag, fmt, arg...)  \        do{\            s8 buf[1024 * 2];\            s32 bytes = 0;\            bytes = sprintf((char*)buf, fmt, ##arg);\            bytes = fwrite(buf, bytes, 1, log_fp);\            fflush(log_fp);\        }while(0)    #else        #include <android/log.h>        #define LOG_TAG "GOODIX"        #define log_print(level, tag, fmt, arg...)   __android_log_print(level, tag, fmt, ##arg)    #endif#endif#if 1#define DEBUG(fmt, arg...)  log_print(ANDROID_LOG_DEBUG, LOG_TAG, "<GT-DBG>"fmt"\n", ##arg)#else#define DEBUG(fmt, arg...)#endif#if 1#define DLINK(fmt, arg...)  log_print(ANDROID_LOG_DEBUG, LOG_TAG, "<JNI-DBG>"fmt"\n", ##arg)#else#define DLINK(fmt, arg...)#endif#if 0#define DEBUG_LINE  log_print(ANDROID_LOG_DEBUG, LOG_TAG, "<--GT-DEBUG-LINE-->%s:%s,%d\n", __FILE__, __FUNCTION__, __LINE__)#else#define DEBUG_LINE#endif#if 1#define DEBUG_ARRAY(array, num)   do{\                               u8* a = array;\                               int i; \                               for (i = 0; i < (num); i++)\                               {\                                    log_print(ANDROID_LOG_DEBUG, LOG_TAG, "%02x  ", (a)[i]);\                                   if ((i + 1 ) %14 == 0)\                                   {\                                        log_print(ANDROID_LOG_DEBUG, LOG_TAG, "\n");\                                   }\                               }\                                log_print(ANDROID_LOG_DEBUG, LOG_TAG, "\n");\                              }while(0)#else#define DEBUG_ARRAY(array, num)#endif#if 0#define DEBUG_DATA(array, num)   do{\                               u16* a = array;\                               int i; \                               for (i = 0; i < (num); i++)\                               {\                                    log_print(ANDROID_LOG_DEBUG, LOG_TAG, "%4d  ", a[i]);\                                   if ((i + 1 ) % DRIVER_NUM== 0)\                                   {\                                        log_print(ANDROID_LOG_DEBUG, LOG_TAG, "\n");\                                   }\                               }\                                log_print(ANDROID_LOG_DEBUG, LOG_TAG, "\n");\                              }while(0)#else#define DEBUG_DATA(array, num)#endif//#define malloc(len) malloc(len);printf("-----------------%s,%d\n", __FILE__, __LINE__);//#define free(p) do{printf("*****************%s,%d, %x\n", __FILE__, __LINE__, p);free(p);}while(0)#endif/*----------------------------------TEST JNI接口--------------------------*/extern s32 write_node(u8*, s32 );extern s32 read_node(u8* , s32 );extern s32 write_data(st_com_cmd_head* );extern s32 read_data(st_com_cmd_head* , u8*);extern s32 read_register(u8*,u16,u16);extern s32 write_register(u8*,u16,u16);extern s32 auto_set_node();extern s32 guitar_reset();extern s32 download_link_code();extern s32 download_authorization_code();extern bool check_crc(u8* ,u16 ,u8 );extern u8 calculate_check_sum(u8* ,u8 );extern bool read_pair_state();extern bool clear_pair_buf();extern bool enter_slave_mode();extern bool enter_master_mode();extern bool enter_transfer_mode();extern bool exit_slave_mode();extern bool exit_master_mode();extern bool exit_transfer_mode();extern bool send_data(u8* buf, s32 length);extern s32 receive_data(u8* buf);extern bool check_authorization();